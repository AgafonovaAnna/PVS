#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <stdint.h>
#include <time.h>

// Размеры массива (примерно 25000000 элементов)
#define SIZE_X 5000
#define SIZE_Y 5000

// Тип данных массива
typedef float arr_t;

// Функция для получения текущего времени (в секундах)
double get_time_sec() {
    return omp_get_wtime();
}

// Инициализация двумерного массива (выделение памяти)
void init(arr_t* arr[], uint32_t sizeX, uint32_t sizeY) {
    for (uint32_t i = 0; i < sizeX; ++i)
        arr[i] = malloc(sizeY * sizeof(arr_t));
}

// Заполнение массива последовательно числами от 1 до size
void fill_sequential(arr_t* arr[], uint32_t sizeX, uint32_t sizeY) {
    #pragma omp parallel for collapse(2)
    for (uint32_t i = 0; i < sizeX; ++i)
        for (uint32_t j = 0; j < sizeY; ++j)
            arr[i][j] = i * sizeY + j + 1;
}

// Освобождение памяти
void free_array(arr_t* arr[], uint32_t sizeX) {
    for (uint32_t i = 0; i < sizeX; ++i)
        free(arr[i]);
}

// Параллельное сложение
void pAddArray(arr_t* a[], arr_t* b[], arr_t* out[], uint32_t sizeX, uint32_t sizeY) {
    #pragma omp parallel for collapse(2)
    for (uint32_t i = 0; i < sizeX; ++i)
        for (uint32_t j = 0; j < sizeY; ++j)
            out[i][j] = a[i][j] + b[i][j];
}

// Параллельное вычитание
void pSubArray(arr_t* a[], arr_t* b[], arr_t* out[], uint32_t sizeX, uint32_t sizeY) {
    #pragma omp parallel for collapse(2)
    for (uint32_t i = 0; i < sizeX; ++i)
        for (uint32_t j = 0; j < sizeY; ++j)
            out[i][j] = a[i][j] - b[i][j];
}

// Параллельное умножение
void pMulArray(arr_t* a[], arr_t* b[], arr_t* out[], uint32_t sizeX, uint32_t sizeY) {
    #pragma omp parallel for collapse(2)
    for (uint32_t i = 0; i < sizeX; ++i)
        for (uint32_t j = 0; j < sizeY; ++j)
            out[i][j] = a[i][j] * b[i][j];
}

// Параллельное деление
void pDivArray(arr_t* a[], arr_t* b[], arr_t* out[], uint32_t sizeX, uint32_t sizeY) {
    #pragma omp parallel for collapse(2)
    for (uint32_t i = 0; i < sizeX; ++i)
        for (uint32_t j = 0; j < sizeY; ++j)
            out[i][j] = b[i][j] ? a[i][j] / b[i][j] : 0;
}

int main() {
    arr_t *a[SIZE_X], *b[SIZE_X], *out[SIZE_X];

    // Тестирование с разным числом потоков
    for (int threads = 2; threads <= 8; threads *= 2) {
        omp_set_num_threads(threads); // Установка числа потоков

        init(a, SIZE_X, SIZE_Y);
        init(b, SIZE_X, SIZE_Y);
        init(out, SIZE_X, SIZE_Y);

        fill_sequential(a, SIZE_X, SIZE_Y);
        fill_sequential(b, SIZE_X, SIZE_Y);

        printf("Используется %d потоков:\n", threads);

        double t1 = get_time_sec();
        pAddArray(a, b, out, SIZE_X, SIZE_Y);
        double t2 = get_time_sec();
        printf("Сложение: %.6f сек\n", t2 - t1);

        t1 = get_time_sec();
        pSubArray(a, b, out, SIZE_X, SIZE_Y);
        t2 = get_time_sec();
        printf("Вычитание: %.6f сек\n", t2 - t1);

        t1 = get_time_sec();
        pMulArray(a, b, out, SIZE_X, SIZE_Y);
        t2 = get_time_sec();
        printf("Умножение: %.6f сек\n", t2 - t1);

        t1 = get_time_sec();
        pDivArray(a, b, out, SIZE_X, SIZE_Y);
        t2 = get_time_sec();
        printf("Деление: %.6f сек\n\n", t2 - t1);

        free_array(a, SIZE_X);
        free_array(b, SIZE_X);
        free_array(out, SIZE_X);
    }

    return 0;
}
